"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrapper = void 0;
const console_1 = require("console");
const path = require("path");
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
const directories_1 = require("../../util/directories");
const deploy_bootstrap_1 = require("./deploy-bootstrap");
const legacy_template_1 = require("./legacy-template");
class Bootstrapper {
    constructor(source) {
        this.source = source;
    }
    bootstrapEnvironment(environment, sdkProvider, options = {}) {
        switch (this.source.source) {
            case 'legacy':
                return this.legacyBootstrap(environment, sdkProvider, options);
            case 'default':
                return this.modernBootstrap(environment, sdkProvider, options);
            case 'custom':
                return this.customBootstrap(environment, sdkProvider, options);
        }
    }
    async showTemplate(json) {
        const template = await this.loadTemplate();
        process.stdout.write(`${serialize_1.serializeStructure(template, json)}\n`);
    }
    /**
     * Deploy legacy bootstrap stack
     *
     */
    async legacyBootstrap(environment, sdkProvider, options = {}) {
        const params = options.parameters ?? {};
        if (params.trustedAccounts?.length) {
            throw new Error('--trust can only be passed for the modern bootstrap experience.');
        }
        if (params.cloudFormationExecutionPolicies?.length) {
            throw new Error('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');
        }
        if (params.createCustomerMasterKey !== undefined) {
            throw new Error('--bootstrap-customer-key can only be passed for the modern bootstrap experience.');
        }
        if (params.qualifier) {
            throw new Error('--qualifier can only be passed for the modern bootstrap experience.');
        }
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, options.toolkitStackName);
        return current.update(await this.loadTemplate(params), {}, {
            ...options,
            terminationProtection: options.terminationProtection ?? current.terminationProtection,
        });
    }
    /**
     * Deploy CI/CD-ready bootstrap stack from template
     *
     */
    async modernBootstrap(environment, sdkProvider, options = {}) {
        const params = options.parameters ?? {};
        const bootstrapTemplate = await this.loadTemplate();
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, options.toolkitStackName);
        if (params.createCustomerMasterKey !== undefined && params.kmsKeyId) {
            throw new Error('You cannot pass \'--bootstrap-kms-key-id\' and \'--bootstrap-customer-key\' together. Specify one or the other');
        }
        // If people re-bootstrap, existing parameter values are reused so that people don't accidentally change the configuration
        // on their bootstrap stack (this happens automatically in deployStack). However, to do proper validation on the
        // combined arguments (such that if --trust has been given, --cloudformation-execution-policies is necessary as well)
        // we need to take this parameter reuse into account.
        //
        // Ideally we'd do this inside the template, but the `Rules` section of CFN
        // templates doesn't seem to be able to express the conditions that we need
        // (can't use Fn::Join or reference Conditions) so we do it here instead.
        const trustedAccounts = params.trustedAccounts ?? splitCfnArray(current.parameters.TrustedAccounts);
        console_1.info(`Trusted accounts for deployment: ${trustedAccounts.length > 0 ? trustedAccounts.join(', ') : '(none)'}`);
        const trustedAccountsForLookup = params.trustedAccountsForLookup ?? splitCfnArray(current.parameters.TrustedAccountsForLookup);
        console_1.info(`Trusted accounts for lookup: ${trustedAccountsForLookup.length > 0 ? trustedAccountsForLookup.join(', ') : '(none)'}`);
        const cloudFormationExecutionPolicies = params.cloudFormationExecutionPolicies ?? splitCfnArray(current.parameters.CloudFormationExecutionPolicies);
        if (trustedAccounts.length === 0 && cloudFormationExecutionPolicies.length === 0) {
            // For self-trust it's okay to default to AdministratorAccess, and it improves the usability of bootstrapping a lot.
            //
            // We don't actually make the implicity policy a physical parameter. The template will infer it instead,
            // we simply do the UI advertising that behavior here.
            //
            // If we DID make it an explicit parameter, we wouldn't be able to tell the difference between whether
            // we inferred it or whether the user told us, and the sequence:
            //
            // $ cdk bootstrap
            // $ cdk bootstrap --trust 1234
            //
            // Would leave AdministratorAccess policies with a trust relationship, without the user explicitly
            // approving the trust policy.
            const implicitPolicy = `arn:${await current.partition()}:iam::aws:policy/AdministratorAccess`;
            logging_1.warning(`Using default execution policy of '${implicitPolicy}'. Pass '--cloudformation-execution-policies' to customize.`);
        }
        else if (cloudFormationExecutionPolicies.length === 0) {
            throw new Error('Please pass \'--cloudformation-execution-policies\' when using \'--trust\' to specify deployment permissions. Try a managed policy of the form \'arn:aws:iam::aws:policy/<PolicyName>\'.');
        }
        else {
            // Remind people what the current settings are
            console_1.info(`Execution policies: ${cloudFormationExecutionPolicies.join(', ')}`);
        }
        // * If an ARN is given, that ARN. Otherwise:
        //   * '-' if customerKey = false
        //   * '' if customerKey = true
        //   * if customerKey is also not given
        //     * undefined if we already had a value in place (reusing what we had)
        //     * '-' if this is the first time we're deploying this stack (or upgrading from old to new bootstrap)
        const currentKmsKeyId = current.parameters.FileAssetsBucketKmsKeyId;
        const kmsKeyId = params.kmsKeyId ??
            (params.createCustomerMasterKey === true ? CREATE_NEW_KEY :
                params.createCustomerMasterKey === false || currentKmsKeyId === undefined ? USE_AWS_MANAGED_KEY :
                    undefined);
        return current.update(bootstrapTemplate, {
            FileAssetsBucketName: params.bucketName,
            FileAssetsBucketKmsKeyId: kmsKeyId,
            // Empty array becomes empty string
            TrustedAccounts: trustedAccounts.join(','),
            TrustedAccountsForLookup: trustedAccountsForLookup.join(','),
            CloudFormationExecutionPolicies: cloudFormationExecutionPolicies.join(','),
            Qualifier: params.qualifier,
            PublicAccessBlockConfiguration: params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === undefined ? 'true' : 'false',
        }, {
            ...options,
            terminationProtection: options.terminationProtection ?? current.terminationProtection,
        });
    }
    async customBootstrap(environment, sdkProvider, options = {}) {
        // Look at the template, decide whether it's most likely a legacy or modern bootstrap
        // template, and use the right bootstrapper for that.
        const version = deploy_bootstrap_1.bootstrapVersionFromTemplate(await this.loadTemplate());
        if (version === 0) {
            return this.legacyBootstrap(environment, sdkProvider, options);
        }
        else {
            return this.modernBootstrap(environment, sdkProvider, options);
        }
    }
    async loadTemplate(params = {}) {
        switch (this.source.source) {
            case 'custom':
                return serialize_1.loadStructuredFile(this.source.templateFile);
            case 'default':
                return serialize_1.loadStructuredFile(path.join(directories_1.rootDir(), 'lib', 'api', 'bootstrap', 'bootstrap-template.yaml'));
            case 'legacy':
                return legacy_template_1.legacyBootstrapTemplate(params);
        }
    }
}
exports.Bootstrapper = Bootstrapper;
/**
 * Magic parameter value that will cause the bootstrap-template.yml to NOT create a CMK but use the default keyo
 */
const USE_AWS_MANAGED_KEY = 'AWS_MANAGED_KEY';
/**
 * Magic parameter value that will cause the bootstrap-template.yml to create a CMK
 */
const CREATE_NEW_KEY = '';
/**
 * Split an array-like CloudFormation parameter on ,
 *
 * An empty string is the empty array (instead of `['']`).
 */
function splitCfnArray(xs) {
    if (xs === '' || xs === undefined) {
        return [];
    }
    return xs.split(',');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwLWVudmlyb25tZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYm9vdHN0cmFwLWVudmlyb25tZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUErQjtBQUMvQiw2QkFBNkI7QUFFN0IsMkNBQXdDO0FBQ3hDLCtDQUF5RTtBQUN6RSx3REFBaUQ7QUFJakQseURBQWtGO0FBQ2xGLHVEQUE0RDtBQVU1RCxNQUFhLFlBQVk7SUFDdkIsWUFBNkIsTUFBdUI7UUFBdkIsV0FBTSxHQUFOLE1BQU0sQ0FBaUI7SUFDcEQsQ0FBQztJQUVNLG9CQUFvQixDQUFDLFdBQThCLEVBQUUsV0FBd0IsRUFBRSxVQUF1QyxFQUFFO1FBQzdILFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDMUIsS0FBSyxRQUFRO2dCQUNYLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ2pFLEtBQUssU0FBUztnQkFDWixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNqRSxLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDbEU7SUFDSCxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFhO1FBQ3JDLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQzNDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsOEJBQWtCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssS0FBSyxDQUFDLGVBQWUsQ0FBQyxXQUE4QixFQUFFLFdBQXdCLEVBQUUsVUFBdUMsRUFBRTtRQUMvSCxN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SUFBSSxDQUFDLHFCQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7WUFDeEcsS0FBSyxRQUFRO2dCQUNYLE9BQU8seUNBQXVCLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDMUM7SUFDSCxDQUFDO0NBQ0Y7QUE5SkQsb0NBOEpDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLG1CQUFtQixHQUFHLGlCQUFpQixDQUFDO0FBRTlDOztHQUVHO0FBQ0gsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBRTFCOzs7O0dBSUc7QUFDSCxTQUFTLGFBQWEsQ0FBQyxFQUFzQjtJQUMzQyxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLFNBQVMsRUFBRTtRQUFFLE9BQU8sRUFBRSxDQUFDO0tBQUU7SUFDakQsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmZvIH0gZnJvbSAnY29uc29sZSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IHdhcm5pbmcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IGxvYWRTdHJ1Y3R1cmVkRmlsZSwgc2VyaWFsaXplU3RydWN0dXJlIH0gZnJvbSAnLi4vLi4vc2VyaWFsaXplJztcbmltcG9ydCB7IHJvb3REaXIgfSBmcm9tICcuLi8uLi91dGlsL2RpcmVjdG9yaWVzJztcbmltcG9ydCB7IFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuLi9kZXBsb3ktc3RhY2snO1xuaW1wb3J0IHsgQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zLCBCb290c3RyYXBwaW5nUGFyYW1ldGVycyB9IGZyb20gJy4vYm9vdHN0cmFwLXByb3BzJztcbmltcG9ydCB7IEJvb3RzdHJhcFN0YWNrLCBib290c3RyYXBWZXJzaW9uRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi9kZXBsb3ktYm9vdHN0cmFwJztcbmltcG9ydCB7IGxlZ2FjeUJvb3RzdHJhcFRlbXBsYXRlIH0gZnJvbSAnLi9sZWdhY3ktdGVtcGxhdGUnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbmV4cG9ydCB0eXBlIEJvb3RzdHJhcFNvdXJjZSA9XG4gIHsgc291cmNlOiAnbGVnYWN5JyB9XG4gIHwgeyBzb3VyY2U6ICdkZWZhdWx0JyB9XG4gIHwgeyBzb3VyY2U6ICdjdXN0b20nOyB0ZW1wbGF0ZUZpbGU6IHN0cmluZyB9O1xuXG5cbmV4cG9ydCBjbGFzcyBCb290c3RyYXBwZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHNvdXJjZTogQm9vdHN0cmFwU291cmNlKSB7XG4gIH1cblxuICBwdWJsaWMgYm9vdHN0cmFwRW52aXJvbm1lbnQoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIHN3aXRjaCAodGhpcy5zb3VyY2Uuc291cmNlKSB7XG4gICAgICBjYXNlICdsZWdhY3knOlxuICAgICAgICByZXR1cm4gdGhpcy5sZWdhY3lCb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gdGhpcy5tb2Rlcm5Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzaG93VGVtcGxhdGUoanNvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtzZXJpYWxpemVTdHJ1Y3R1cmUodGVtcGxhdGUsIGpzb24pfVxcbmApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBsZWdhY3kgYm9vdHN0cmFwIHN0YWNrXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGxlZ2FjeUJvb3RzdHJhcChlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlciwgb3B0aW9uczogQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zID0ge30pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG4gICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5wYXJhbWV0ZXJzID8/IHt9O1xuXG4gICAgaWYgKHBhcmFtcy50cnVzdGVkQWNjb3VudHM/Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCctLXRydXN0IGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignLS1jbG91ZGZvcm1hdGlvbi1leGVjdXRpb24tcG9saWNpZXMgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignLS1ib290c3RyYXAtY3VzdG9tZXIta2V5IGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5xdWFsaWZpZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignLS1xdWFsaWZpZXIgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FpdCBCb290c3RyYXBTdGFjay5sb29rdXAoc2RrUHJvdmlkZXIsIGVudmlyb25tZW50LCBvcHRpb25zLnRvb2xraXRTdGFja05hbWUpO1xuICAgIHJldHVybiBjdXJyZW50LnVwZGF0ZShhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZShwYXJhbXMpLCB7fSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogb3B0aW9ucy50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gY3VycmVudC50ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95IENJL0NELXJlYWR5IGJvb3RzdHJhcCBzdGFjayBmcm9tIHRlbXBsYXRlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIG1vZGVybkJvb3RzdHJhcChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuXG4gICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5wYXJhbWV0ZXJzID8/IHt9O1xuXG4gICAgY29uc3QgYm9vdHN0cmFwVGVtcGxhdGUgPSBhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZSgpO1xuXG4gICAgY29uc3QgY3VycmVudCA9IGF3YWl0IEJvb3RzdHJhcFN0YWNrLmxvb2t1cChzZGtQcm92aWRlciwgZW52aXJvbm1lbnQsIG9wdGlvbnMudG9vbGtpdFN0YWNrTmFtZSk7XG5cbiAgICBpZiAocGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zLmttc0tleUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcGFzcyBcXCctLWJvb3RzdHJhcC1rbXMta2V5LWlkXFwnIGFuZCBcXCctLWJvb3RzdHJhcC1jdXN0b21lci1rZXlcXCcgdG9nZXRoZXIuIFNwZWNpZnkgb25lIG9yIHRoZSBvdGhlcicpO1xuICAgIH1cblxuICAgIC8vIElmIHBlb3BsZSByZS1ib290c3RyYXAsIGV4aXN0aW5nIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHJldXNlZCBzbyB0aGF0IHBlb3BsZSBkb24ndCBhY2NpZGVudGFsbHkgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uXG4gICAgLy8gb24gdGhlaXIgYm9vdHN0cmFwIHN0YWNrICh0aGlzIGhhcHBlbnMgYXV0b21hdGljYWxseSBpbiBkZXBsb3lTdGFjaykuIEhvd2V2ZXIsIHRvIGRvIHByb3BlciB2YWxpZGF0aW9uIG9uIHRoZVxuICAgIC8vIGNvbWJpbmVkIGFyZ3VtZW50cyAoc3VjaCB0aGF0IGlmIC0tdHJ1c3QgaGFzIGJlZW4gZ2l2ZW4sIC0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzIGlzIG5lY2Vzc2FyeSBhcyB3ZWxsKVxuICAgIC8vIHdlIG5lZWQgdG8gdGFrZSB0aGlzIHBhcmFtZXRlciByZXVzZSBpbnRvIGFjY291bnQuXG4gICAgLy9cbiAgICAvLyBJZGVhbGx5IHdlJ2QgZG8gdGhpcyBpbnNpZGUgdGhlIHRlbXBsYXRlLCBidXQgdGhlIGBSdWxlc2Agc2VjdGlvbiBvZiBDRk5cbiAgICAvLyB0ZW1wbGF0ZXMgZG9lc24ndCBzZWVtIHRvIGJlIGFibGUgdG8gZXhwcmVzcyB0aGUgY29uZGl0aW9ucyB0aGF0IHdlIG5lZWRcbiAgICAvLyAoY2FuJ3QgdXNlIEZuOjpKb2luIG9yIHJlZmVyZW5jZSBDb25kaXRpb25zKSBzbyB3ZSBkbyBpdCBoZXJlIGluc3RlYWQuXG4gICAgY29uc3QgdHJ1c3RlZEFjY291bnRzID0gcGFyYW1zLnRydXN0ZWRBY2NvdW50cyA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5UcnVzdGVkQWNjb3VudHMpO1xuICAgIGluZm8oYFRydXN0ZWQgYWNjb3VudHMgZm9yIGRlcGxveW1lbnQ6ICR7dHJ1c3RlZEFjY291bnRzLmxlbmd0aCA+IDAgPyB0cnVzdGVkQWNjb3VudHMuam9pbignLCAnKSA6ICcobm9uZSknfWApO1xuXG4gICAgY29uc3QgdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwID0gcGFyYW1zLnRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cCA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5UcnVzdGVkQWNjb3VudHNGb3JMb29rdXApO1xuICAgIGluZm8oYFRydXN0ZWQgYWNjb3VudHMgZm9yIGxvb2t1cDogJHt0cnVzdGVkQWNjb3VudHNGb3JMb29rdXAubGVuZ3RoID4gMCA/IHRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cC5qb2luKCcsICcpIDogJyhub25lKSd9YCk7XG5cbiAgICBjb25zdCBjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzID0gcGFyYW1zLmNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMgPz8gc3BsaXRDZm5BcnJheShjdXJyZW50LnBhcmFtZXRlcnMuQ2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcyk7XG4gICAgaWYgKHRydXN0ZWRBY2NvdW50cy5sZW5ndGggPT09IDAgJiYgY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEZvciBzZWxmLXRydXN0IGl0J3Mgb2theSB0byBkZWZhdWx0IHRvIEFkbWluaXN0cmF0b3JBY2Nlc3MsIGFuZCBpdCBpbXByb3ZlcyB0aGUgdXNhYmlsaXR5IG9mIGJvb3RzdHJhcHBpbmcgYSBsb3QuXG4gICAgICAvL1xuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgbWFrZSB0aGUgaW1wbGljaXR5IHBvbGljeSBhIHBoeXNpY2FsIHBhcmFtZXRlci4gVGhlIHRlbXBsYXRlIHdpbGwgaW5mZXIgaXQgaW5zdGVhZCxcbiAgICAgIC8vIHdlIHNpbXBseSBkbyB0aGUgVUkgYWR2ZXJ0aXNpbmcgdGhhdCBiZWhhdmlvciBoZXJlLlxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIERJRCBtYWtlIGl0IGFuIGV4cGxpY2l0IHBhcmFtZXRlciwgd2Ugd291bGRuJ3QgYmUgYWJsZSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gd2hldGhlclxuICAgICAgLy8gd2UgaW5mZXJyZWQgaXQgb3Igd2hldGhlciB0aGUgdXNlciB0b2xkIHVzLCBhbmQgdGhlIHNlcXVlbmNlOlxuICAgICAgLy9cbiAgICAgIC8vICQgY2RrIGJvb3RzdHJhcFxuICAgICAgLy8gJCBjZGsgYm9vdHN0cmFwIC0tdHJ1c3QgMTIzNFxuICAgICAgLy9cbiAgICAgIC8vIFdvdWxkIGxlYXZlIEFkbWluaXN0cmF0b3JBY2Nlc3MgcG9saWNpZXMgd2l0aCBhIHRydXN0IHJlbGF0aW9uc2hpcCwgd2l0aG91dCB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAvLyBhcHByb3ZpbmcgdGhlIHRydXN0IHBvbGljeS5cbiAgICAgIGNvbnN0IGltcGxpY2l0UG9saWN5ID0gYGFybjoke2F3YWl0IGN1cnJlbnQucGFydGl0aW9uKCl9OmlhbTo6YXdzOnBvbGljeS9BZG1pbmlzdHJhdG9yQWNjZXNzYDtcbiAgICAgIHdhcm5pbmcoYFVzaW5nIGRlZmF1bHQgZXhlY3V0aW9uIHBvbGljeSBvZiAnJHtpbXBsaWNpdFBvbGljeX0nLiBQYXNzICctLWNsb3VkZm9ybWF0aW9uLWV4ZWN1dGlvbi1wb2xpY2llcycgdG8gY3VzdG9taXplLmApO1xuICAgIH0gZWxzZSBpZiAoY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHBhc3MgXFwnLS1jbG91ZGZvcm1hdGlvbi1leGVjdXRpb24tcG9saWNpZXNcXCcgd2hlbiB1c2luZyBcXCctLXRydXN0XFwnIHRvIHNwZWNpZnkgZGVwbG95bWVudCBwZXJtaXNzaW9ucy4gVHJ5IGEgbWFuYWdlZCBwb2xpY3kgb2YgdGhlIGZvcm0gXFwnYXJuOmF3czppYW06OmF3czpwb2xpY3kvPFBvbGljeU5hbWU+XFwnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1pbmQgcGVvcGxlIHdoYXQgdGhlIGN1cnJlbnQgc2V0dGluZ3MgYXJlXG4gICAgICBpbmZvKGBFeGVjdXRpb24gcG9saWNpZXM6ICR7Y2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5qb2luKCcsICcpfWApO1xuICAgIH1cblxuICAgIC8vICogSWYgYW4gQVJOIGlzIGdpdmVuLCB0aGF0IEFSTi4gT3RoZXJ3aXNlOlxuICAgIC8vICAgKiAnLScgaWYgY3VzdG9tZXJLZXkgPSBmYWxzZVxuICAgIC8vICAgKiAnJyBpZiBjdXN0b21lcktleSA9IHRydWVcbiAgICAvLyAgICogaWYgY3VzdG9tZXJLZXkgaXMgYWxzbyBub3QgZ2l2ZW5cbiAgICAvLyAgICAgKiB1bmRlZmluZWQgaWYgd2UgYWxyZWFkeSBoYWQgYSB2YWx1ZSBpbiBwbGFjZSAocmV1c2luZyB3aGF0IHdlIGhhZClcbiAgICAvLyAgICAgKiAnLScgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBkZXBsb3lpbmcgdGhpcyBzdGFjayAob3IgdXBncmFkaW5nIGZyb20gb2xkIHRvIG5ldyBib290c3RyYXApXG4gICAgY29uc3QgY3VycmVudEttc0tleUlkID0gY3VycmVudC5wYXJhbWV0ZXJzLkZpbGVBc3NldHNCdWNrZXRLbXNLZXlJZDtcbiAgICBjb25zdCBrbXNLZXlJZCA9IHBhcmFtcy5rbXNLZXlJZCA/P1xuICAgICAgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSA9PT0gdHJ1ZSA/IENSRUFURV9ORVdfS0VZIDpcbiAgICAgICAgcGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ID09PSBmYWxzZSB8fCBjdXJyZW50S21zS2V5SWQgPT09IHVuZGVmaW5lZCA/IFVTRV9BV1NfTUFOQUdFRF9LRVkgOlxuICAgICAgICAgIHVuZGVmaW5lZCk7XG5cbiAgICByZXR1cm4gY3VycmVudC51cGRhdGUoXG4gICAgICBib290c3RyYXBUZW1wbGF0ZSxcbiAgICAgIHtcbiAgICAgICAgRmlsZUFzc2V0c0J1Y2tldE5hbWU6IHBhcmFtcy5idWNrZXROYW1lLFxuICAgICAgICBGaWxlQXNzZXRzQnVja2V0S21zS2V5SWQ6IGttc0tleUlkLFxuICAgICAgICAvLyBFbXB0eSBhcnJheSBiZWNvbWVzIGVtcHR5IHN0cmluZ1xuICAgICAgICBUcnVzdGVkQWNjb3VudHM6IHRydXN0ZWRBY2NvdW50cy5qb2luKCcsJyksXG4gICAgICAgIFRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cDogdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwLmpvaW4oJywnKSxcbiAgICAgICAgQ2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llczogY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5qb2luKCcsJyksXG4gICAgICAgIFF1YWxpZmllcjogcGFyYW1zLnF1YWxpZmllcixcbiAgICAgICAgUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uOiBwYXJhbXMucHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uIHx8IHBhcmFtcy5wdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb24gPT09IHVuZGVmaW5lZCA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICB9LCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogb3B0aW9ucy50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gY3VycmVudC50ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3VzdG9tQm9vdHN0cmFwKFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gICAgb3B0aW9uczogQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zID0ge30pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG5cbiAgICAvLyBMb29rIGF0IHRoZSB0ZW1wbGF0ZSwgZGVjaWRlIHdoZXRoZXIgaXQncyBtb3N0IGxpa2VseSBhIGxlZ2FjeSBvciBtb2Rlcm4gYm9vdHN0cmFwXG4gICAgLy8gdGVtcGxhdGUsIGFuZCB1c2UgdGhlIHJpZ2h0IGJvb3RzdHJhcHBlciBmb3IgdGhhdC5cbiAgICBjb25zdCB2ZXJzaW9uID0gYm9vdHN0cmFwVmVyc2lvbkZyb21UZW1wbGF0ZShhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZSgpKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVnYWN5Qm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVybkJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZFRlbXBsYXRlKHBhcmFtczogQm9vdHN0cmFwcGluZ1BhcmFtZXRlcnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgc3dpdGNoICh0aGlzLnNvdXJjZS5zb3VyY2UpIHtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiBsb2FkU3RydWN0dXJlZEZpbGUodGhpcy5zb3VyY2UudGVtcGxhdGVGaWxlKTtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gbG9hZFN0cnVjdHVyZWRGaWxlKHBhdGguam9pbihyb290RGlyKCksICdsaWInLCAnYXBpJywgJ2Jvb3RzdHJhcCcsICdib290c3RyYXAtdGVtcGxhdGUueWFtbCcpKTtcbiAgICAgIGNhc2UgJ2xlZ2FjeSc6XG4gICAgICAgIHJldHVybiBsZWdhY3lCb290c3RyYXBUZW1wbGF0ZShwYXJhbXMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hZ2ljIHBhcmFtZXRlciB2YWx1ZSB0aGF0IHdpbGwgY2F1c2UgdGhlIGJvb3RzdHJhcC10ZW1wbGF0ZS55bWwgdG8gTk9UIGNyZWF0ZSBhIENNSyBidXQgdXNlIHRoZSBkZWZhdWx0IGtleW9cbiAqL1xuY29uc3QgVVNFX0FXU19NQU5BR0VEX0tFWSA9ICdBV1NfTUFOQUdFRF9LRVknO1xuXG4vKipcbiAqIE1hZ2ljIHBhcmFtZXRlciB2YWx1ZSB0aGF0IHdpbGwgY2F1c2UgdGhlIGJvb3RzdHJhcC10ZW1wbGF0ZS55bWwgdG8gY3JlYXRlIGEgQ01LXG4gKi9cbmNvbnN0IENSRUFURV9ORVdfS0VZID0gJyc7XG5cbi8qKlxuICogU3BsaXQgYW4gYXJyYXktbGlrZSBDbG91ZEZvcm1hdGlvbiBwYXJhbWV0ZXIgb24gLFxuICpcbiAqIEFuIGVtcHR5IHN0cmluZyBpcyB0aGUgZW1wdHkgYXJyYXkgKGluc3RlYWQgb2YgYFsnJ11gKS5cbiAqL1xuZnVuY3Rpb24gc3BsaXRDZm5BcnJheSh4czogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nW10ge1xuICBpZiAoeHMgPT09ICcnIHx8IHhzID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIFtdOyB9XG4gIHJldHVybiB4cy5zcGxpdCgnLCcpO1xufVxuIl19